#include <iostream>

using namespace std;

/*
 * - n == 2 일 때는, 선공이 승리하는 것은 자명하다.
 * - n >= 3 일 때는 다음과 같은 전략이 성립한다.
 * 
 *  1) n이 홀수 일 때:
 *    - 관찰에 의해, 후공은 항상 크기가 1이 아닌 연결 요소의 개수를 하나로 유지할 수 있다.
 *    - 선공은 자신의 차례때 크기가 1이 아닌 연결 요소를 1개 또는 2개가 되도록 만들 수 있다.
 *    - 2개로 만드는 경우란, 기존 연결 요소에 속하지 않는 정점 둘을 연결 하는 것이다.
 *    - 하지만 이때 기존의 연결 요소의 크기가 홀수이므로, 후공은 이 두 연결 요소를 하나로 합칠 수 있게 된다.
 *    - 결국 후공은 모든 정점을 하나의 연결 요소로 만들 수 있으므로 승리하게 된다.
 * 
 *  2) n이 짝수 일 때:
 *    - 후공은 연결 요소의 개수가 3개가 남을 때까지 위와 같은 전략을 유지할 수 있다.
 *    - 연결 요소의 개수가 3개가 되면 후공의 차례가 되고, 이때 크기가 짝수인 연결 요소 2개를 만들 수 있다.
 *    - 따라서 후공이 승리하게 된다.
 * 
 * 결론:
 * - n == 2 : 선공 승리
 * - n >= 3 : 후공 승리
*/

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t;

    while (t--) {
        int n;
        cin >> n;

        if (n == 2) {
            cout << "kang\n";
        } else {
            cout << "chan\n";
        }
    }

    return 0;
}